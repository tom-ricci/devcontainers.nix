name: build

on:
  workflow_dispatch:
    inputs:
      package:
        required: true
        type: string
      runs-on:
        required: true
        default: "ubuntu-latest"
        type: choice
        options:
          - ubuntu-latest
          - ubuntu-24.04-arm
      free-disk-space:
        required: false
        default: false
        type: boolean

  workflow_call:
    inputs:
      package:
        required: true
        type: string
      runs-on:
        required: true
        type: string
      free-disk-space:
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io

jobs:
  build-and-push:
    runs-on: ${{ inputs.runs-on }}

    permissions:
      packages: write

    steps:
      - uses: AdityaGarg8/remove-unwanted-software@90e01b21170618765a73370fcc3abbd1684a7793
        if: ${{ inputs.free-disk-space }}
        with:
          remove-dotnet: "true"
          remove-android: "true"
          remove-haskell: "true"
          remove-codeql: "true"
          remove-docker-images: "false"
          remove-large-packages: "true"
          remove-cached-tools: "true"
          remove-swapfile: "false"
          verbose: "true"

      - uses: actions/checkout@v4

      # https://github.com/orgs/community/discussions/42479#discussioncomment-4484937
      # https://github.com/wph95/opentelemetry-demo-webstore/blob/ae08811157db7ba590a7c8dd6faa2cb9d1473bef/.github/workflows/release.yml#L24-L29
      # limit docker push image concurrency to 1
      # to avoid github package return 429 ratelimit error
      - name: Set docker upload concurrent
        run: |
          echo $'{"max-concurrent-downloads": 50, "max-concurrent-uploads": 2}' | sudo dd status=none of=/etc/docker/daemon.json
          sudo service docker restart

      # https://discourse.nixos.org/t/building-docker-image-in-github-actions-leads-to-skopeo-related-issues/40636/4
      - name: Fix dockerTools.pullImage issue
        run: |
          sudo chmod 755 /run/containers
          sudo mkdir -p "/run/containers/$(id -u runner)"
          sudo chown runner: "/run/containers/$(id -u runner)"

      - uses: nixbuild/nix-quick-install-action@5bb6a3b3abe66fd09bbf250dce8ada94f856a703 # v30
        with:
          enable_kvm: true

      # - uses: nix-community/cache-nix-action@aee88ae5efbbeb38ac5d9862ecbebdb404a19e69 # v6
      #   with:
      #     # The Nix store is already hash-based, so there's no need to use hashFile to bypass cachingâ€”just periodically purging it will suffice.
      #     primary-key: build-${{ runner.os }}-${{ runner.arch }}
      #     purge: true
      #     purge-last-accessed: 2629800 # 1 month
      #     purge-prefixes: build-${{ runner.os }}-${{ runner.arch }}-
      #     purge-primary-key: never

      - name: Log in to the Container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: build and push ${{ inputs.package }}
        run: |
          nix eval --json $".#packages.x86_64-linux.${{ inputs.package }}" --apply 'x: "${x.imageName}"'

          IMAGE_NAME="$(nix eval --json $".#packages.x86_64-linux.${{ inputs.package }}" --apply 'x: "${x.imageName}"' | jq -r)"
          if [ -z "$IMAGE_NAME" ]; then
            echo failed to get IMAGE_NAME
            exit 1
          fi

          IMAGE_TAG="$(nix eval --json $".#packages.x86_64-linux.${{ inputs.package }}" --apply 'x: "${x.imageTag}"' | jq -r)"
          if [ -z "$IMAGE_TAG" ]; then
            echo failed to get IMAGE_TAG
            exit 1
          fi

          IMAGE_FULL_NAME="$IMAGE_NAME:$IMAGE_TAG"

          docker pull "$IMAGE_FULL_NAME" || true
          ori_digest="$(docker inspect "$IMAGE_FULL_NAME" | jq -r '.[] | .Id' || true)"
          echo ori_digest $ori_digest
          ori_size="$(docker inspect "$IMAGE_FULL_NAME" | jq -r '.[] | .Size' || true)"
          echo ori_size $ori_size

          if [[ -n "$ori_size" && "$ori_size" -ge 10000000000 ]]; then
            docker rmi "$IMAGE_FULL_NAME" || true
          fi

          nix run .#${{ inputs.package }}
          new_digest="$(docker inspect "$IMAGE_FULL_NAME" | jq -r '.[] | .Id' || true)"
          echo new_digest $new_digest

          if [ -z "$new_digest" ]; then
            echo failed to get new_digest
            exit 1
          fi

          if [ "$new_digest" = "$ori_digest" ]; then
            echo no change
            exit 0
          fi

          ARCH="$(docker info --format json | jq -r '.ClientInfo.Arch')"
          echo ARCH $ARCH

          docker tag "$IMAGE_FULL_NAME" "$IMAGE_FULL_NAME-$ARCH"
          docker push "$IMAGE_FULL_NAME-$ARCH"

          docker rmi "$IMAGE_FULL_NAME"
          docker rmi "$IMAGE_FULL_NAME-$ARCH"
